from abc import ABC, abstractmethod
from random import getrandbits
from typing import Dict, List, Tuple, Callable

import keyboard
import numpy as np
from noise import snoise3

from lighting import ColorFunction, ReactiveFunction, combine_keys_and_functions, single_color, NoisePalette, \
    WordPalette, SpectrogramGenerator, key_grid_by_row, key_grid_by_col, Color, KeyIndex, scale_map, flatten, \
    CombineType, Mask


class LightingScheme(ABC):
    def __init__(self, row_major: bool = False):
        """
        A LightingScheme provides a Ducky instance with Colors according to pairs of KeyIndex-ColorFunction pairs.

        Three methods are defined for all LightingSchemes:
        ::
            get_color()      : gets a Color specific to a KeyIndex
            get_all_colors() : gets the Colors for each key in a Mask
            update()         : called in get_all_colors for dynamic LightingSchemes

        :param row_major: whether or not this LightingScheme should be represented by row-major KeyIndices
        """
        self.row_major = row_major
        pass

    @abstractmethod
    def get_color(self, key: KeyIndex, *args, **kwargs) -> Color:
        """
        Gets the Color of a single key. Additional args and kwargs can be passed, if used by the LightingScheme.
        """
        pass

    def update(self, *args, **kwargs) -> None:
        """
        Updates data required for getting the Color of keys. Additional args and kwargs can be passed, if used by the
        LightingScheme.
        """
        pass

    def get_all_colors(self, mask: Mask = Mask.ALL, *args, **kwargs) -> Dict[KeyIndex, Color]:
        """
        Gets the Color for every key in mask. Additional args and kwargs can be passed, if used by the LightingScheme.
        """
        self.update(*args, **kwargs)
        out = {}
        if self.row_major:
            keys = flatten(key_grid_by_row)
        else:
            keys = flatten(key_grid_by_col)
        for key in keys:
            if key is not None:
                index = KeyIndex(key, self.row_major)
                if str(key) not in mask:
                    out[index] = Color(0, 0, 0)
                else:
                    out[index] = self.get_color(index, *args, **kwargs)

        return out


class FunctionScheme(LightingScheme):
    def __init__(self, color_functions: Dict[KeyIndex, ColorFunction], row_major: bool = False):
        """
        A FunctionScheme is the simplest type of LightingScheme, where each KeyIndex is paired with a ColorFunction that can
        be used to get a color from a KeyIndex.

        :param color_functions: a dict of ColorFunctions corresponding to every KeyIndex
        :param row_major: whether or not this LightingScheme should be represented by row-major KeyIndices
        """
        super().__init__(row_major)
        self.color_functions = color_functions

    def get_color(self, key: KeyIndex, *args, **kwargs) -> Color:
        return self.color_functions[key].get(*args, **kwargs)


class SolidColorScheme(FunctionScheme):
    def __init__(self, color: Color, row_major: bool = False):
        """
        A SolidColorScheme is a FunctionScheme where every key is lit with the same Color. This is for convenience.
        :param color: The Color to use for all of the keys
        :param row_major: whether or not this LightingScheme should be represented by row-major KeyIndices
        """
        functions = combine_keys_and_functions(single_color(len(Mask.ALL), color))
        super().__init__(functions, row_major)


class NoiseScheme(LightingScheme):
    def __init__(self, palette: NoisePalette, row_major: bool = False):
        """
        A NoiseScheme produces Colors from a NoisePalette, using float values generated by Perlin Noise. This is
        functionally identical to the FastLED NoisePlusPalette Arduino example found at:
        https://github.com/FastLED/FastLED/blob/master/examples/NoisePlusPalette/NoisePlusPalette.ino

        The update() method has been changed to do the following:
        ::
            Adjust Perlin Noise values across the grid, based on the previous position

        :param palette: the NoisePalette to use for get_color()
        :param row_major: whether or not this LightingScheme should be represented by row-major KeyIndices
        """
        super().__init__(row_major)
        self.palette = palette
        if row_major:
            self.noise = np.random.random(np.shape(key_grid_by_row))
        else:
            self.noise = np.random.random(np.shape(key_grid_by_col))
        self.x = getrandbits(16)
        self.y = getrandbits(16)
        self.z = getrandbits(16)

    def update(self, *args, **kwargs) -> None:
        new_noise = np.zeros(self.noise.shape)
        for y in range(new_noise.shape[0]):
            y_shift = self.palette.scale * y
            for x in range(new_noise.shape[1]):
                x_shift = self.palette.scale * x
                new_noise[y][x] = snoise3(self.x + x_shift, self.y + y_shift, self.z) * 0.5 + 0.5

        self.noise = (1 - self.palette.smoothing) * new_noise + self.palette.smoothing * self.noise

        self.x += self.palette.speed / 8
        self.y -= self.palette.speed / 16
        self.z += self.palette.speed / 4

    def get_color(self, key: KeyIndex, *args, **kwargs) -> Color:
        return self.palette.get_color(self.noise[key[0]][key[1]])


class WordScheme(FunctionScheme):
    def __init__(self, palette: WordPalette):
        """
        A WordScheme uses a WordPalette to generate key Colors to look like a word being displayed.
        Assumes that row_major is False.
        """
        super().__init__(palette.functions, False)
        self.palette = palette

    def get_color(self, key: KeyIndex, *args, **kwargs) -> Color:
        mask = self.palette.get_rolled_map()
        if mask[key[0]][key[1]] == 1:
            return super().get_color(key, *args, **kwargs)
        return Color(0, 0, 0)


class SpectrogramScheme(FunctionScheme):
    def __init__(self, color_functions: Dict[KeyIndex, ColorFunction], min_brightness: float = 0.6,
                 row_major: bool = False):
        """
        A SpectrogramScheme uses a SpectrogramGenerator to modify the output of get_color. The scaled value produced is
        determined by the occurrences of various frequencies in the SpectrogramGenerator's input. If min_brightness
        isn't 1.0, then the Colors outputted get more dim as they move up the bar.

        :param color_functions: underlying functions to light up
        :param min_brightness: if between 0.0 and 1.0, determines how dim the higher bars can get
        :param row_major: whether or not this LightingScheme should be represented by row-major KeyIndices
        """
        super().__init__(color_functions, row_major)
        if row_major:
            self._grid = key_grid_by_row
        else:
            self._grid = key_grid_by_col
        self._shape = np.shape(self._grid)
        self._sg_gen = SpectrogramGenerator(self._shape[0], self._shape[1])
        self._min_brightness = min_brightness
        self._heights = []

    def update(self, *args, **kwargs) -> None:
        self._sg_gen.update_data()
        self._heights = self._sg_gen.get_mapped_heights()

    def get_color(self, key: KeyIndex, *args, **kwargs) -> Color:
        height = self._heights[key[0]]
        y = key[1]
        if y < height:
            return super().get_color(key, *args, **kwargs) * scale_map(height - y, 0, height, self._min_brightness, 1)
        return Color(0, 0, 0)


class HookingScheme(LightingScheme, ABC):
    def __init__(self, mask: Mask = Mask.ALL, row_major: bool = False, *args, **kwargs):
        """
        A HookingScheme has unique behavior from other LightingSchemes in that it has unique behavior when keys are
        pressed. These keyboard hooks are set up with _setup_hooks(), which should be implemented by subclasses.
        :param mask: a mask to apply the hooking behavior to
        :param row_major: whether or not this LightingScheme should be represented by row-major KeyIndices
        :param args: additional arguments passed into _setup_hooks()
        :param kwargs: additional keyword arguments passed into _setup_hooks()
        """
        super().__init__(row_major)
        self.mask = mask
        functions, hook = self._setup_hooks(*args, **kwargs)
        self.color_functions: Dict[KeyIndex, ColorFunction] = functions
        self.hook = hook

    @abstractmethod
    def _setup_hooks(self, *args, **kwargs) -> Tuple[
        Dict[KeyIndex, ColorFunction], Callable[[keyboard.KeyboardEvent], None]]:
        pass


class ReactiveScheme(HookingScheme):
    def __init__(self, base_scheme: LightingScheme, decay: float = 0.25, mask: Mask = Mask.ALL,
                 row_major: bool = False):
        """
        A ReactiveScheme turns any LightingScheme into a scheme has keys light up when pressed.
        :param base_scheme: the LightingScheme to convert into a ReactiveScheme
        :param decay: how much time (in seconds) it should take for the keys light to turn off
        :param mask: a mask to apply the hooking behavior to
        :param row_major: whether or not this LightingScheme should be represented by row-major KeyIndices
        """
        super().__init__(mask, row_major, base_scheme=base_scheme, decay=decay)

    def _setup_hooks(self, *args, **kwargs) -> Tuple[
        Dict[KeyIndex, ColorFunction], Callable[[keyboard.KeyboardEvent], None]]:
        functions: Dict[KeyIndex, ReactiveFunction] = {}

        scheme = kwargs["base_scheme"]
        decay = kwargs["decay"]

        for key in self.mask:
            def callable_get_color(*args__, **kwargs__):
                return scheme.get_color(KeyIndex(key, False), *args__, **kwargs__)

            functions[KeyIndex(key, False)] = (ReactiveFunction(callable_get_color, key, decay))

        def callback(event: keyboard.KeyboardEvent):
            for function in functions.values():
                if event.event_type == keyboard.KEY_DOWN:
                    function.on_press(event)
                else:
                    function.on_release(event)

        return functions, callback

    def get_color(self, key: KeyIndex, *args, **kwargs) -> Color:
        return self.color_functions[key].get(*args, **kwargs)


class CombiningScheme(LightingScheme):
    def __init__(self, *schemes: Tuple[LightingScheme, CombineType, Mask], row_major: bool = False):
        """
        A CombiningScheme combines the effects of multiple LightingSchemes according to CombineTypes.

        The schemes implemented first will be at the bottom
        """
        super().__init__(row_major)
        self.hooks = []
        for scheme, combine_type, mask in schemes:
            if isinstance(scheme, HookingScheme):
                self.hooks.append(scheme.hook)
            if isinstance(scheme, CombiningScheme):
                self.hooks += scheme.hooks
        self.schemes: List[Tuple[LightingScheme, CombineType, Mask]] = list(schemes)

    def add_scheme(self, scheme: LightingScheme, combine_type: CombineType = CombineType.Overlay,
                   mask: Mask = Mask.ALL):
        self.schemes.append((scheme, combine_type, mask))
        if isinstance(scheme, HookingScheme):
            self.hooks.append(scheme.hook)
        if isinstance(scheme, CombiningScheme):
            self.hooks += scheme.hooks

    def remove_scheme(self, scheme: LightingScheme):
        self.schemes = [s for s in self.schemes if s[0] != scheme]
        if isinstance(scheme, HookingScheme):
            self.hooks.remove(scheme.hook)
        if isinstance(scheme, CombiningScheme):
            self.hooks -= scheme.hooks

    def clear_schemes(self):
        for s in self.schemes:
            if isinstance(s, HookingScheme):
                self.hooks.remove(s.hook)
            if isinstance(s, CombiningScheme):
                self.hooks -= s.hooks
        self.schemes = []

    def update(self, *args, **kwargs):
        for scheme in self.schemes:
            scheme[0].update(*args, **kwargs)

    def get_color(self, key: KeyIndex, *args, **kwargs) -> Color:
        out = Color(0, 0, 0)
        for scheme, combine_type, mask in self.schemes:
            if str(key) in mask:
                if combine_type == CombineType.Overlay:
                    color = scheme.get_color(key, *args, **kwargs)
                    if not color.is_zero():
                        out = color
                elif combine_type == CombineType.Add:
                    out += scheme.get_color(key, *args, **kwargs)
                elif combine_type == CombineType.Subtract:
                    out = out - scheme.get_color(key, *args, **kwargs)

        return out
